(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{294:function(a,t,e){"use strict";e.r(t);var s=e(6),o=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"popobj-and-popdata-types"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#popobj-and-popdata-types"}},[a._v("#")]),a._v(" PopObj and PopData types")]),a._v(" "),e("p",[a._v("For the PopGen.jl package to be consistent, a standard flexible data structure needs to be defined. The solution is a custom type called  "),e("code",[a._v("PopData")]),a._v(". The struct is defined as:")]),a._v(" "),e("div",{staticClass:"language-julia extra-class"},[e("pre",{pre:!0,attrs:{class:"language-julia"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("struct")]),a._v(" PopData\n\tmeta"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("IndexedTable\n\tloci"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("IndexedTable\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("end")]),a._v("\n")])])]),e("p",[a._v("As you can see, a "),e("code",[a._v("PopData")]),a._v(" is made up of two IndexedTables (from "),e("a",{attrs:{href:"https://github.com/JuliaComputing/JuliaDB.jl",target:"_blank",rel:"noopener noreferrer"}},[a._v("JuliaDB.jl"),e("OutboundLink")],1),a._v("), one called "),e("code",[a._v("meta")]),a._v(" for sample information (metadata), and the other called "),e("code",[a._v("loci")]),a._v(" which includes genotype information. This structure allows for easy and convenient access to the fields using dot "),e("code",[a._v(".")]),a._v(" accessors.. The "),e("code",[a._v("meta")]),a._v(" and "),e("code",[a._v("loci")]),a._v(" tables are both specific in their structure, so here is an illustration to help you visualize a "),e("code",[a._v("PopData")]),a._v(" object:")]),a._v(" "),e("p",[e("img",{attrs:{src:"/PopGen.jl/images/PopData.svg",alt:"PopData"}})]),a._v(" "),e("p",[e("code",[a._v("PopData")]),a._v(" and other custom types introduced in PopGen.jl fall under an AbstractType we call "),e("code",[a._v("PopObj")]),a._v(', which is short for "PopGen Object".')]),a._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[a._v('pronouncing "PopObj"')]),a._v(" "),e("p",[a._v('It\'s not super obvious, but we decided to pronounce PopObj as "pop ob" with a silent j because it sounds better than saying "pop obj", but writing it as PopOb looks weird. It\'s a silly little detail that Pavel seems to care a lot about.')])]),a._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[a._v("avoid manual creation!")]),a._v(" "),e("p",[a._v("While it may seem simple enough to create two IndexedTables and make a "),e("code",[a._v("PopData")]),a._v(" out of them, the structure of "),e("code",[a._v("meta")]),a._v(" and "),e("code",[a._v("loci")]),a._v(" are specific, so small mistakes in creating them can create many errors and prevent PopGen from working correctly on your data. Please use the included "),e("code",[a._v("csv")]),a._v(", "),e("code",[a._v("genepop")]),a._v(", and "),e("code",[a._v("vcf")]),a._v(" file importers instead.")])]),a._v(" "),e("h2",{attrs:{id:"metadata"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#metadata"}},[a._v("#")]),a._v(" Metadata")]),a._v(" "),e("p",[a._v("The "),e("code",[a._v("meta")]),a._v(" table has 5 specific categories/columns: name, population, ploidy, longitude, latitude. These can be directly accessed with "),e("code",[a._v("PopData.meta.columns.colname")]),a._v(" where "),e("code",[a._v("PopData")]),a._v(" is the name of your PopData object, and "),e("code",[a._v("colname")]),a._v(" is one of the five column names below.")]),a._v(" "),e("h3",{attrs:{id:"name"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#name"}},[a._v("#")]),a._v(" name")]),a._v(" "),e("p",[e("code",[a._v("::Vector{String}")])]),a._v(" "),e("p",[a._v("The individual/sample names")]),a._v(" "),e("div",{staticClass:"language-julia extra-class"},[e("pre",{pre:!0,attrs:{class:"language-julia"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"ind_001"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"ind_002"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"ind_003"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n")])])]),e("h3",{attrs:{id:"population"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#population"}},[a._v("#")]),a._v(" population")]),a._v(" "),e("p",[e("code",[a._v("::Vector{String}")])]),a._v(" "),e("p",[a._v("The individual/sample population ID's")]),a._v(" "),e("div",{staticClass:"language-julia extra-class"},[e("pre",{pre:!0,attrs:{class:"language-julia"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"borneo"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"borneo"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"new jersey"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n")])])]),e("h3",{attrs:{id:"ploidy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ploidy"}},[a._v("#")]),a._v(" ploidy")]),a._v(" "),e("p",[e("code",[a._v("::Vector{Int8}")])]),a._v(" "),e("p",[a._v("The ploidy of the samples")]),a._v(" "),e("div",{staticClass:"language-julia extra-class"},[e("pre",{pre:!0,attrs:{class:"language-julia"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n")])])]),e("h3",{attrs:{id:"longitude"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#longitude"}},[a._v("#")]),a._v(" longitude")]),a._v(" "),e("p",[e("code",[a._v("::Vector{Union{Missing,Float32}}")])]),a._v(" "),e("p",[a._v("latitude data of samples (decimal degrees)")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[-11.12, 15.32, 11.02, -4.42]\n")])])]),e("h3",{attrs:{id:"latitude"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#latitude"}},[a._v("#")]),a._v(" latitude")]),a._v(" "),e("p",[e("code",[a._v("::Vector{Union{Missing,Float64}}")])]),a._v(" "),e("p",[a._v("longitude data of samples (decimal degrees)")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[-11.12, 15.32, 11.02, -4]\n")])])]),e("h2",{attrs:{id:"genotype-information"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#genotype-information"}},[a._v("#")]),a._v(" Genotype Information")]),a._v(" "),e("p",[a._v("The genotype information is stored in a separate table called "),e("code",[a._v("loci")]),a._v('. This table is rather special in that it is stored in "tidy" format, i.e. one record per row. Storing data this way makes it a lot easier to interrogate the data and write new functions, along with leveraging '),e("a",{attrs:{href:"https://github.com/piever/JuliaDBMeta.jl",target:"_blank",rel:"noopener noreferrer"}},[a._v("JuliaDBMeta.jl"),e("OutboundLink")],1),a._v(". It also means the table will have as many rows as loci x samples, which can become a lot. To reduce redundant objects inflating object size, the columns name, population, and locus are "),e("code",[a._v("CategoricalStrings")]),a._v("  from "),e("a",{attrs:{href:"https://github.com/JuliaData/CategoricalArrays.jl",target:"_blank",rel:"noopener noreferrer"}},[a._v("CategoricalArrays.jl"),e("OutboundLink")],1),a._v(", which is a memory-saving data structure for long repetitive categorical data. Without using this format, "),e("code",[a._v("gulfsharks")]),a._v(", whose source file is 3.2mb, would occupy about 27mb in your RAM! The classes of "),e("code",[a._v(".loci")]),a._v(" can be directly accessed with "),e("code",[a._v("PopData.loci.columns.colname")]),a._v(" where "),e("code",[a._v("PopData")]),a._v(" is the name of your PopData object, and "),e("code",[a._v("colname")]),a._v(" is one of the four column names below.")]),a._v(" "),e("h3",{attrs:{id:"name-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#name-2"}},[a._v("#")]),a._v(" name")]),a._v(" "),e("p",[e("code",[a._v("::Vector{CategoricalString}")])]),a._v(" "),e("p",[a._v("The sample name, stored as a "),e("code",[a._v("CategoricalString")]),a._v(". Fundamentally, this acts like the "),e("code",[a._v("name")]),a._v(" column of the "),e("code",[a._v("meta")]),a._v(" table, except when deleting entries and a few uncommon edge cases.")]),a._v(" "),e("h3",{attrs:{id:"population-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#population-2"}},[a._v("#")]),a._v(" population")]),a._v(" "),e("p",[e("code",[a._v("::Vector{CategoricalString}")])]),a._v(" "),e("p",[a._v("The population ID associated with that sample, stored as a "),e("code",[a._v("CategoricalString")]),a._v(". Fundamentally, this acts like the "),e("code",[a._v("population")]),a._v(" column of the "),e("code",[a._v("meta")]),a._v(" table, except when deleting entries and a few uncommon edge cases.")]),a._v(" "),e("h3",{attrs:{id:"locus"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#locus"}},[a._v("#")]),a._v(" locus")]),a._v(" "),e("p",[e("code",[a._v("::Vector{CategoricalString}")])]),a._v(" "),e("p",[a._v("The locus associated with the genotype, stored as a "),e("code",[a._v("CategoricalString")]),a._v(".")]),a._v(" "),e("h3",{attrs:{id:"genotype"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#genotype"}},[a._v("#")]),a._v(" genotype")]),a._v(" "),e("p",[e("code",[a._v("::Vector{Union{Missing,Genotype}}")])]),a._v(" "),e("p",[a._v("The genotypes of the "),e("code",[a._v("loci")]),a._v(" are an array of type "),e("code",[a._v("Genotype")]),a._v(", which is an alias for a built-in Julia Tuple type with each value corresponding to an allele (read below to disentangle what that type actually is). For the most part, it looks like this:")]),a._v(" "),a._v('" extra-class">'),e("pre",{pre:!0,attrs:{class:"language-julia"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" missing"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[a._v("immutable genotypes")]),a._v(" "),e("p",[a._v("We use the Tuple type for genotypes of individuals because they are "),e("strong",[a._v("immutable")]),a._v(" (cannot be changed). By the time you're using PopGen.jl, your data should already be filtered and screened. Hand-editing of genotype alleles is "),e("strong",[a._v("strongly")]),a._v(" discouraged, so we outlawed it.")])]),a._v(" "),e("h2",{attrs:{id:"viewing-popdata"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#viewing-popdata"}},[a._v("#")]),a._v(" Viewing PopData")]),a._v(" "),e("p",[a._v("Given the volume of information that can be present in a "),e("code",[a._v("PopData")]),a._v(", we recommend "),e("code",[a._v("summary()")]),a._v(" to summarize/overview the data rather than regurgitate everything on the screen.")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("julia> a = gulfsharks() ;\n\njulia> summary(a)\nPopData Object\n  Marker type: SNP\n  Ploidy: 2\n  Number of individuals: 212\n  Number of loci: 2213\n  Populations: 7\n  Longitude: present with 0 missing\n  Latitude: present with 0 missing\n")])])]),e("h2",{attrs:{id:"location-data"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#location-data"}},[a._v("#")]),a._v(" location data")]),a._v(" "),e("p",[a._v("Location data is optional for a "),e("code",[a._v("PopData")]),a._v(". There are functions that use location information (e.g. "),e("code",[a._v("locations")]),a._v("), but most don't, so it's not a dealbreaker. At present, there are no analyses that utilize location information.")])])}),[],!1,null,null,null);t.default=o.exports}}]);